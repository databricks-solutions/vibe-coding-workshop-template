---
description: Unity Catalog Primary Key and Foreign Key constraint patterns for proper relational modeling in Databricks
globs: src/**/*.py
---

# Unity Catalog Primary Key and Foreign Key Constraints

## Pattern Recognition
Unity Catalog supports informational constraints (NOT ENFORCED) that enrich metadata, improve query optimization, and enable BI tool relationship discovery. This rule standardizes PK/FK implementation for star schema dimensional models.

## Core Principle: Surrogate Keys as Primary Keys

**❌ WRONG: Business keys as PKs, facts reference business keys**
```sql
-- This breaks when facts need surrogate FKs!
CREATE TABLE dim_store (
    store_key STRING NOT NULL,  -- Surrogate key (not PK)
    store_number STRING NOT NULL PRIMARY KEY,  -- Business key as PK
    ...
)

-- Facts reference business keys, not surrogate keys
CREATE TABLE fact_sales (
    store_number STRING NOT NULL,  -- Business key
    ...
    CONSTRAINT fk_sales_store FOREIGN KEY (store_number) 
        REFERENCES dim_store(store_number) NOT ENFORCED
)
-- ❌ PROBLEM: Facts don't have surrogate keys for performance
-- ❌ PROBLEM: Can't leverage surrogate key benefits (integer joins, SCD Type 2)
```

**✅ CORRECT: Surrogate keys as PKs, facts reference surrogate keys**
```sql
-- PK on surrogate key (proper dimensional modeling)
CREATE TABLE dim_store (
    store_key STRING NOT NULL,  -- Surrogate PK
    store_number STRING NOT NULL,  -- Business key (UNIQUE)
    ...
    CONSTRAINT pk_dim_store PRIMARY KEY (store_key) NOT ENFORCED,
    CONSTRAINT uk_store_number UNIQUE (store_number) NOT ENFORCED
)

-- Facts reference dimension surrogate PKs
CREATE TABLE fact_sales (
    store_key STRING NOT NULL,  -- Surrogate FK
    store_number STRING NOT NULL,  -- Business key (for readability)
    ...
    CONSTRAINT fk_sales_store FOREIGN KEY (store_key) 
        REFERENCES dim_store(store_key) NOT ENFORCED
)
-- ✅ CORRECT: Facts have surrogate FKs
-- ✅ CORRECT: Business keys preserved for human readability
-- ✅ CORRECT: Follows Kimball dimensional modeling best practices
```

## Databricks FK Constraint Requirement

### Critical Rule
**Foreign keys MUST reference PRIMARY KEY columns, even when NOT ENFORCED.**

This means:
- You cannot create FK to any column, only to PK columns
- FKs must reference the exact column(s) in the PK definition
- This applies even to informational (NOT ENFORCED) constraints

### Why This Matters for Star Schemas
In dimensional models:
- **Facts should reference surrogate keys** (store_key, product_key, date_key)
- **Surrogate keys are PRIMARY KEYS** (unique, auto-generated identifiers)
- **Business keys have UNIQUE constraints** (for alternate lookups)
- **Solution**: Define PKs on surrogate keys, facts reference surrogate PKs, business keys preserved for readability

## NOT NULL Requirement for Primary Keys

### Error You'll See
```
AnalysisException: Cannot create the primary key `pk_dim_product` because 
its child column(s) `product_key` is nullable. Please change the column nullability and retry.
```

### Solution
**All surrogate key columns used in PKs MUST be NOT NULL.**

```sql
-- ❌ WRONG: Nullable surrogate key
CREATE TABLE dim_product (
    product_key STRING,  -- ❌ Nullable, cannot be PK
    upc_code STRING NOT NULL,
    ...
)

-- ✅ CORRECT: NOT NULL surrogate key
CREATE TABLE dim_product (
    product_key STRING NOT NULL,  -- ✅ Can be PK
    upc_code STRING NOT NULL,  -- Business key (UNIQUE)
    ...
    CONSTRAINT pk_dim_product PRIMARY KEY (product_key) NOT ENFORCED,
    CONSTRAINT uk_product_upc UNIQUE (upc_code) NOT ENFORCED
)
```

## Standard Dimensional Model Pattern

### Dimension Table (SCD Type 2)

```sql
CREATE TABLE dim_store (
    -- Surrogate key (PRIMARY KEY)
    store_key STRING NOT NULL 
        COMMENT 'Surrogate key (unique per version) - PRIMARY KEY',
    
    -- Business key (UNIQUE constraint, not PK)
    store_number STRING NOT NULL 
        COMMENT 'Business key - Store identifier',
    
    -- Attributes
    store_name STRING,
    address STRING,
    city STRING,
    state STRING,
    
    -- SCD Type 2 fields
    effective_from TIMESTAMP NOT NULL,
    effective_to TIMESTAMP,
    is_current BOOLEAN NOT NULL,
    
    -- Timestamps
    record_created_timestamp TIMESTAMP,
    record_updated_timestamp TIMESTAMP,
    
    -- PRIMARY KEY on surrogate key
    CONSTRAINT pk_dim_store PRIMARY KEY (store_key) NOT ENFORCED
    
    -- Note: No UNIQUE constraint on store_number for SCD Type 2
    -- (same store_number can have multiple versions)
)
USING DELTA
CLUSTER BY AUTO
TBLPROPERTIES (
    'delta.enableChangeDataFeed' = 'true',
    'layer' = 'gold',
    'scd_type' = '2'
)
COMMENT 'Gold layer store dimension with SCD Type 2';
```

**Note:** For SCD Type 2, facts join to `dim_store.store_key` (surrogate PK), and filter `WHERE is_current = true` to get the latest version.

### Dimension Table (SCD Type 1)

```sql
CREATE TABLE dim_product (
    -- Surrogate key (PRIMARY KEY)
    product_key STRING NOT NULL 
        COMMENT 'Surrogate key - PRIMARY KEY',
    
    -- Business key (UNIQUE constraint)
    upc_code STRING NOT NULL 
        COMMENT 'Universal Product Code - Business key',
    
    -- Attributes
    sku_description STRING,
    brand STRING,
    manufacturer STRING,
    
    -- Timestamps
    record_created_timestamp TIMESTAMP,
    record_updated_timestamp TIMESTAMP,
    
    -- PRIMARY KEY on surrogate key
    CONSTRAINT pk_dim_product PRIMARY KEY (product_key) NOT ENFORCED,
    
    -- UNIQUE constraint on business key
    CONSTRAINT uk_product_upc UNIQUE (upc_code) NOT ENFORCED
)
USING DELTA
CLUSTER BY AUTO
TBLPROPERTIES (
    'delta.enableChangeDataFeed' = 'true',
    'layer' = 'gold',
    'scd_type' = '1'
)
COMMENT 'Gold layer product dimension';
```

### Date Dimension

```sql
CREATE TABLE dim_date (
    -- Surrogate key (PRIMARY KEY, integer format for fast joins)
    date_key INT NOT NULL 
        COMMENT 'Integer YYYYMMDD format - PRIMARY KEY',
    
    -- Natural date (UNIQUE constraint)
    date DATE NOT NULL 
        COMMENT 'Actual date - Business key',
    
    -- Attributes
    year INT,
    month INT,
    month_name STRING,
    day_of_week INT,
    day_of_week_name STRING,
    quarter INT,
    is_weekend BOOLEAN,
    
    record_created_timestamp TIMESTAMP,
    
    -- PRIMARY KEY on surrogate key
    CONSTRAINT pk_dim_date PRIMARY KEY (date_key) NOT ENFORCED,
    
    -- UNIQUE constraint on natural date
    CONSTRAINT uk_date_value UNIQUE (date) NOT ENFORCED
)
USING DELTA
CLUSTER BY AUTO
COMMENT 'Gold layer date dimension';
```

### Fact Table with Foreign Keys

```sql
CREATE TABLE fact_sales_daily (
    -- Surrogate foreign key columns (reference dimension PKs)
    store_key STRING NOT NULL,
    product_key STRING NOT NULL,
    date_key INT NOT NULL,
    
    -- Business keys (for readability, not part of PK/FK)
    store_number STRING NOT NULL,
    upc_code STRING NOT NULL,
    transaction_date DATE NOT NULL,
    
    -- Measures
    gross_revenue DOUBLE,
    net_revenue DOUBLE,
    units_sold INT,
    transaction_count INT,
    
    -- Timestamps
    record_created_timestamp TIMESTAMP,
    record_updated_timestamp TIMESTAMP,
    
    -- Composite PRIMARY KEY on surrogate keys (grain of fact table)
    CONSTRAINT pk_fact_sales_daily 
        PRIMARY KEY (store_key, product_key, date_key) NOT ENFORCED,
    
    -- FOREIGN KEYS to dimension surrogate PKs
    CONSTRAINT fk_sales_store 
        FOREIGN KEY (store_key) 
        REFERENCES dim_store(store_key) NOT ENFORCED,
    
    CONSTRAINT fk_sales_product 
        FOREIGN KEY (product_key) 
        REFERENCES dim_product(product_key) NOT ENFORCED,
    
    CONSTRAINT fk_sales_date 
        FOREIGN KEY (date_key) 
        REFERENCES dim_date(date_key) NOT ENFORCED
)
USING DELTA
CLUSTER BY AUTO
TBLPROPERTIES (
    'delta.enableChangeDataFeed' = 'true',
    'layer' = 'gold'
)
COMMENT 'Gold layer daily sales fact table';
```

**Key Points:**
- Facts have **surrogate FKs** (store_key, product_key, date_key) for proper relationships
- Business keys (store_number, upc_code, transaction_date) **preserved for readability**
- All FKs reference **surrogate PKs** in dimensions (Databricks requirement)
- Fast integer joins with date_key vs date comparisons

## Implementation Pattern in Python

### Embed Constraints in Table Creation Script

```python
def add_primary_and_foreign_keys(spark: SparkSession, catalog: str, schema: str):
    """Add PRIMARY KEY and FOREIGN KEY constraints to all Gold tables.
    
    Strategy: Define PKs on surrogate keys (proper dimensional modeling).
    Facts reference dimension surrogate keys via FK constraints.
    """
    print("\nADDING PRIMARY KEY AND FOREIGN KEY CONSTRAINTS")
    
    # Drop existing constraints for idempotency
    constraint_map = {
        "dim_store": ["pk_dim_store", "fk_sales_store", "fk_inventory_store"],
        "dim_product": ["pk_dim_product", "uk_product_upc", "fk_sales_product", "fk_inventory_product"],
        "dim_date": ["pk_dim_date", "uk_date_value", "fk_sales_date"],
        "fact_sales_daily": ["pk_fact_sales_daily", "fk_sales_store", "fk_sales_product", "fk_sales_date"],
        "fact_inventory_snapshot": ["pk_fact_inventory_snapshot", "fk_inventory_store", "fk_inventory_product"]
    }
    
    for table, constraints in constraint_map.items():
        for constraint_name in constraints:
            try:
                spark.sql(f"ALTER TABLE {catalog}.{schema}.{table} DROP CONSTRAINT IF EXISTS {constraint_name}")
            except Exception:
                pass
    
    # Add Primary Keys on surrogate keys
    spark.sql(f"""
        ALTER TABLE {catalog}.{schema}.dim_store
        ADD CONSTRAINT pk_dim_store PRIMARY KEY (store_key) NOT ENFORCED
    """)
    
    spark.sql(f"""
        ALTER TABLE {catalog}.{schema}.dim_product
        ADD CONSTRAINT pk_dim_product PRIMARY KEY (product_key) NOT ENFORCED
    """)
    
    spark.sql(f"""
        ALTER TABLE {catalog}.{schema}.dim_date
        ADD CONSTRAINT pk_dim_date PRIMARY KEY (date_key) NOT ENFORCED
    """)
    
    # Add UNIQUE constraints on business keys
    spark.sql(f"""
        ALTER TABLE {catalog}.{schema}.dim_product
        ADD CONSTRAINT uk_product_upc UNIQUE (upc_code) NOT ENFORCED
    """)
    
    spark.sql(f"""
        ALTER TABLE {catalog}.{schema}.dim_date
        ADD CONSTRAINT uk_date_value UNIQUE (date) NOT ENFORCED
    """)
    
    # Add Composite PKs on facts (surrogate keys)
    spark.sql(f"""
        ALTER TABLE {catalog}.{schema}.fact_sales_daily
        ADD CONSTRAINT pk_fact_sales_daily 
        PRIMARY KEY (store_key, product_key, date_key) NOT ENFORCED
    """)
    
    # Add Foreign Keys to surrogate PKs
    spark.sql(f"""
        ALTER TABLE {catalog}.{schema}.fact_sales_daily
        ADD CONSTRAINT fk_sales_store 
        FOREIGN KEY (store_key) 
        REFERENCES {catalog}.{schema}.dim_store(store_key) NOT ENFORCED
    """)
    
    spark.sql(f"""
        ALTER TABLE {catalog}.{schema}.fact_sales_daily
        ADD CONSTRAINT fk_sales_product 
        FOREIGN KEY (product_key) 
        REFERENCES {catalog}.{schema}.dim_product(product_key) NOT ENFORCED
    """)
    
    spark.sql(f"""
        ALTER TABLE {catalog}.{schema}.fact_sales_daily
        ADD CONSTRAINT fk_sales_date 
        FOREIGN KEY (date_key) 
        REFERENCES {catalog}.{schema}.dim_date(date_key) NOT ENFORCED
    """)
    
    print("✅ All constraints added successfully!")
    print("  • PKs on surrogate keys (store_key, product_key, date_key)")
    print("  • UNIQUE constraints on business keys (upc_code, date)")
    print("  • FKs reference surrogate PKs")
```

## Benefits of NOT ENFORCED Constraints

| Benefit | Description |
|---------|-------------|
| **Zero Runtime Overhead** | Constraints are not validated at write time |
| **Unity Catalog Metadata** | Relationships documented in UC for lineage |
| **Query Optimization** | Optimizer leverages PK/FK metadata for better plans |
| **BI Tool Discovery** | Tools like Tableau/Power BI auto-discover relationships |
| **Flexible Data Loading** | Late-arriving dimensions don't cause load failures |

## Validation Checklist

When implementing constraints:
- [ ] All surrogate key columns are `NOT NULL`
- [ ] PKs defined on surrogate keys (proper dimensional modeling)
- [ ] FKs reference surrogate PK columns exactly
- [ ] Facts have surrogate FK columns (store_key, product_key, date_key)
- [ ] Business keys have UNIQUE constraints (where applicable)
- [ ] All constraints include `NOT ENFORCED`
- [ ] Constraint names are descriptive (e.g., `pk_dim_store`, `uk_product_upc`, `fk_sales_store`)
- [ ] Drop existing constraints before adding (idempotency)
- [ ] Constraints embedded in table creation script
- [ ] Facts join to dimensions via surrogate keys
- [ ] Business keys preserved in facts for readability

## Common Mistakes to Avoid

### ❌ Mistake 1: PK on business key, facts without surrogate keys
```sql
-- This prevents proper surrogate key usage
CREATE TABLE dim_store (
    store_key STRING NOT NULL,
    store_number STRING NOT NULL PRIMARY KEY,  -- ❌ Business key as PK
    ...
)

CREATE TABLE fact_sales (
    store_number STRING NOT NULL,  -- ❌ No surrogate key
    ...
    PRIMARY KEY (store_number, upc_code, date) NOT ENFORCED
)
```

### ❌ Mistake 2: Nullable surrogate key
```sql
-- Cannot be used as PK
product_key STRING COMMENT 'Surrogate key'  -- ❌ Nullable
```

### ❌ Mistake 3: FK references non-PK column
```sql
-- This fails even with NOT ENFORCED
FOREIGN KEY (store_number) REFERENCES dim_store(store_number)  -- ❌ Not the PK
```

### ✅ Correct Pattern
```sql
-- Surrogate key as NOT NULL and PK
CREATE TABLE dim_store (
    store_key STRING NOT NULL,
    store_number STRING NOT NULL,
    ...
    CONSTRAINT pk_dim_store PRIMARY KEY (store_key) NOT ENFORCED
)

-- Fact with surrogate FK
CREATE TABLE fact_sales (
    store_key STRING NOT NULL,  -- ✅ Surrogate FK
    store_number STRING NOT NULL,  -- Business key for readability
    ...
    CONSTRAINT pk_fact_sales PRIMARY KEY (store_key, product_key, date_key) NOT ENFORCED,
    CONSTRAINT fk_sales_store FOREIGN KEY (store_key) 
        REFERENCES dim_store(store_key) NOT ENFORCED
)
```

## Design Philosophy

### Proper Dimensional Modeling

Follow Kimball dimensional modeling best practices:
- ✅ **Surrogate keys as PRIMARY KEYS** (unique, auto-generated)
- ✅ **Facts reference surrogate PKs** (proper FK relationships)
- ✅ **Business keys have UNIQUE constraints** (alternate lookups)
- ✅ **Business keys preserved in facts** (human readability)
- ✅ **SCD Type 2 works correctly** (store_key unique per version)

### Surrogate Keys Provide Benefits

With PKs on surrogate keys:
- ✅ **Fast joins**: Integer date_key vs date comparisons
- ✅ **SCD Type 2**: store_key uniquely identifies each version
- ✅ **Stable identifiers**: Surrogate keys don't change
- ✅ **Query optimization**: Optimizer leverages PK/FK metadata
- ✅ **BI tool integration**: Proper relationships for Tableau/Power BI

## References

- [Unity Catalog Constraints](https://docs.databricks.com/data-governance/unity-catalog/constraints.html)
- [Primary and Foreign Keys](https://docs.databricks.com/tables/constraints.html#declare-primary-key-and-foreign-key-relationships)
- [Dimensional Modeling Best Practices](https://www.kimballgroup.com/data-warehouse-business-intelligence-resources/kimball-techniques/dimensional-modeling-techniques/)
- [Star Schema Design](https://docs.databricks.com/lakehouse-architecture/medallion.html)
